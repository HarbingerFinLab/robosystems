name: Graph Maintenance

on:
  workflow_dispatch:
    inputs:
      task:
        description: "Maintenance task to perform"
        required: true
        type: choice
        options:
          - update-ami
          - docker-cleanup
      environment:
        description: "Environment"
        required: true
        type: choice
        options:
          - staging
          - prod
      trigger_deploy:
        description: "Trigger a deploy after updating AMI (default: just update variable for next release)"
        required: false
        type: boolean
        default: false
      deploy_ref:
        description: "Git ref to deploy from (defaults to latest release tag, only used if trigger_deploy is true)"
        required: false
        type: string
        default: ""

  # Monthly schedule for AMI updates - controlled by GRAPH_AMI_AUTO_UPDATE variable
  # Staging runs first (1st of month), Prod follows next day (2nd of month)
  schedule:
    - cron: "0 7 1 * *" # AMI: Staging 1st of month at 7am UTC
    - cron: "0 7 2 * *" # AMI: Prod 2nd of month at 7am UTC
    # Weekly Docker cleanup - every Sunday at 6am UTC (before typical work hours)
    - cron: "0 6 * * 0" # Docker: Both envs every Sunday

permissions:
  id-token: write
  contents: read
  actions: write

concurrency:
  # Use environment for manual runs, cron schedule for scheduled runs (distinguishes staging vs prod)
  group: graph-maintenance-${{ inputs.environment || github.event.schedule }}
  cancel-in-progress: false

jobs:
  # For scheduled runs, determine task type and check if enabled
  schedule-gate:
    if: github.event_name == 'schedule'
    runs-on: ubuntu-latest
    timeout-minutes: 5
    outputs:
      should_run: ${{ steps.check.outputs.should_run }}
      environment: ${{ steps.check.outputs.environment }}
      task: ${{ steps.check.outputs.task }}
    steps:
      - name: Check if scheduled runs are enabled
        id: check
        run: |
          CRON="${{ github.event.schedule }}"

          # Docker cleanup: Sunday at 6am UTC - always enabled, runs for both envs
          if [[ "$CRON" == "0 6 * * 0" ]]; then
            echo "task=docker-cleanup" >> $GITHUB_OUTPUT
            echo "should_run=true" >> $GITHUB_OUTPUT
            echo "environment=both" >> $GITHUB_OUTPUT
            echo "Weekly Docker cleanup triggered"
            exit 0
          fi

          # AMI update: 1st/2nd of month - requires GRAPH_AMI_AUTO_UPDATE=true
          echo "task=update-ami" >> $GITHUB_OUTPUT
          SETTING="${{ vars.GRAPH_AMI_AUTO_UPDATE }}"
          if [ "$SETTING" == "true" ]; then
            # 1st of month = staging, 2nd of month = prod
            if [[ "$CRON" == "0 7 1 "* ]]; then
              ENV="staging"
            else
              ENV="prod"
            fi
            echo "should_run=true" >> $GITHUB_OUTPUT
            echo "environment=$ENV" >> $GITHUB_OUTPUT
            echo "Scheduled AMI update is enabled, will run for $ENV"
          else
            echo "should_run=false" >> $GITHUB_OUTPUT
            echo "environment=" >> $GITHUB_OUTPUT
            echo "Scheduled AMI update is disabled (set GRAPH_AMI_AUTO_UPDATE=true to enable)"
          fi

  # =============================================================================
  # Task: update-ami
  # Updates the GRAPH_AMI_ID variable with the latest Amazon Linux 2023 ARM64 AMI.
  # By default, only updates the variable - deploy happens with next release.
  # If trigger_deploy is true, triggers a full deploy to update Launch Templates.
  # =============================================================================
  ami-get-latest:
    # always() needed because schedule-gate is skipped for workflow_dispatch
    if: |
      always() &&
      ((github.event_name == 'workflow_dispatch' && inputs.task == 'update-ami') ||
      (github.event_name == 'schedule' && needs.schedule-gate.outputs.should_run == 'true' && needs.schedule-gate.outputs.task == 'update-ami'))
    needs: [schedule-gate]
    runs-on: ubuntu-latest
    timeout-minutes: 10
    outputs:
      ami_id: ${{ steps.ami.outputs.ami_id }}
      ami_name: ${{ steps.ami.outputs.ami_name }}
      current_ami: ${{ steps.current.outputs.current_ami }}
      var_name: ${{ steps.current.outputs.var_name }}
      ami_changed: ${{ steps.compare.outputs.ami_changed }}
      has_token: ${{ steps.check-token.outputs.has_token }}
      # Pass-through inputs for downstream jobs
      environment: ${{ steps.inputs.outputs.environment }}
      trigger_deploy: ${{ steps.inputs.outputs.trigger_deploy }}
      deploy_ref: ${{ steps.inputs.outputs.deploy_ref }}
    steps:
      - name: Check ACTIONS_TOKEN availability
        id: check-token
        run: |
          if [ -z "${{ secrets.ACTIONS_TOKEN }}" ]; then
            echo "has_token=false" >> $GITHUB_OUTPUT
            echo "::warning::ACTIONS_TOKEN not set - will show AMI info but cannot update variables"
          else
            echo "has_token=true" >> $GITHUB_OUTPUT
          fi

      - name: Resolve inputs
        id: inputs
        run: |
          if [ "${{ github.event_name }}" == "schedule" ]; then
            echo "environment=${{ needs.schedule-gate.outputs.environment }}" >> $GITHUB_OUTPUT
            # GRAPH_AMI_AUTO_DEPLOY controls whether scheduled runs also trigger deploy
            TRIGGER_DEPLOY="${{ vars.GRAPH_AMI_AUTO_DEPLOY }}"
            if [ "$TRIGGER_DEPLOY" == "true" ]; then
              echo "trigger_deploy=true" >> $GITHUB_OUTPUT
              echo "Scheduled run for ${{ needs.schedule-gate.outputs.environment }} (will deploy if AMI changed)"
            else
              echo "trigger_deploy=false" >> $GITHUB_OUTPUT
              echo "Scheduled run for ${{ needs.schedule-gate.outputs.environment }} (variable update only)"
            fi
            echo "deploy_ref=" >> $GITHUB_OUTPUT
          else
            echo "environment=${{ inputs.environment }}" >> $GITHUB_OUTPUT
            echo "trigger_deploy=${{ inputs.trigger_deploy }}" >> $GITHUB_OUTPUT
            echo "deploy_ref=${{ inputs.deploy_ref }}" >> $GITHUB_OUTPUT
            echo "Manual run for ${{ inputs.environment }}"
          fi

      - name: Checkout
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.ACTIONS_TOKEN || github.token }}

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ vars.AWS_ROLE_ARN }}
          aws-region: ${{ vars.AWS_REGION || 'us-east-1' }}

      - name: Get Latest AMI
        id: ami
        uses: ./.github/actions/get-latest-ami
        with:
          architecture: arm64

      - name: Get Current AMI Variable
        id: current
        env:
          GH_TOKEN: ${{ secrets.ACTIONS_TOKEN }}
        run: |
          ENV="${{ steps.inputs.outputs.environment }}"
          VAR_NAME="GRAPH_AMI_ID_$(echo $ENV | tr '[:lower:]' '[:upper:]')"
          # gh variable requires PAT - will show "not-set" if token missing
          if [ -z "$GH_TOKEN" ]; then
            CURRENT_AMI="not-set"
            echo "âš ï¸ Cannot read variable without ACTIONS_TOKEN"
          else
            CURRENT_AMI=$(gh variable get "$VAR_NAME" 2>/dev/null || echo "not-set")
          fi
          echo "current_ami=$CURRENT_AMI" >> $GITHUB_OUTPUT
          echo "var_name=$VAR_NAME" >> $GITHUB_OUTPUT
          echo "Current $VAR_NAME: $CURRENT_AMI"

      - name: Compare AMIs
        id: compare
        run: |
          if [ "${{ steps.ami.outputs.ami_id }}" != "${{ steps.current.outputs.current_ami }}" ]; then
            echo "ami_changed=true" >> $GITHUB_OUTPUT
            echo "AMI has changed!"
            echo "  Current: ${{ steps.current.outputs.current_ami }}"
            echo "  Latest:  ${{ steps.ami.outputs.ami_id }}"
          else
            echo "ami_changed=false" >> $GITHUB_OUTPUT
            echo "AMI is already up to date: ${{ steps.ami.outputs.ami_id }}"
          fi

  ami-update-variable:
    if: |
      always() &&
      needs.ami-get-latest.result == 'success' &&
      needs.ami-get-latest.outputs.ami_changed == 'true' &&
      needs.ami-get-latest.outputs.has_token == 'true'
    needs: [ami-get-latest]
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Update AMI Variable
        env:
          GH_TOKEN: ${{ secrets.ACTIONS_TOKEN }}
        run: |
          VAR_NAME="${{ needs.ami-get-latest.outputs.var_name }}"
          echo "Updating $VAR_NAME to: ${{ needs.ami-get-latest.outputs.ami_id }}"
          gh variable set "$VAR_NAME" --body "${{ needs.ami-get-latest.outputs.ami_id }}"
          echo "Variable updated successfully"

  ami-trigger-deploy:
    if: |
      always() &&
      needs.ami-update-variable.result == 'success' &&
      needs.ami-get-latest.outputs.trigger_deploy == 'true'
    needs: [ami-get-latest, ami-update-variable]
    runs-on: ubuntu-latest
    timeout-minutes: 45
    outputs:
      run_id: ${{ steps.trigger.outputs.run_id }}
      deploy_ref: ${{ steps.trigger.outputs.deploy_ref }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Trigger Deploy Workflow
        id: trigger
        env:
          GH_TOKEN: ${{ secrets.ACTIONS_TOKEN }}
        run: |
          WORKFLOW="${{ needs.ami-get-latest.outputs.environment }}.yml"

          # Determine deploy ref (use input or latest release tag)
          if [ -n "${{ needs.ami-get-latest.outputs.deploy_ref }}" ]; then
            DEPLOY_REF="${{ needs.ami-get-latest.outputs.deploy_ref }}"
            echo "Using specified ref: $DEPLOY_REF"
          else
            DEPLOY_REF=$(gh release view --json tagName --jq '.tagName')
            echo "Using latest release tag: $DEPLOY_REF"
          fi

          # Validate ref is a semver tag (vX.Y.Z) or main branch
          if [[ "$DEPLOY_REF" != "main" && ! "$DEPLOY_REF" =~ ^v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "::error::Invalid deploy ref: $DEPLOY_REF"
            echo "Must be 'main' or a semver tag (e.g., v1.2.3)"
            exit 1
          fi

          echo "Triggering $WORKFLOW workflow from ref: $DEPLOY_REF"
          gh workflow run "$WORKFLOW" --ref "$DEPLOY_REF"

          # Wait a moment for the run to be created
          sleep 5

          # Get the run ID of the triggered workflow
          RUN_ID=$(gh run list --workflow="$WORKFLOW" --limit 1 --json databaseId --jq '.[0].databaseId')
          echo "run_id=$RUN_ID" >> $GITHUB_OUTPUT
          echo "deploy_ref=$DEPLOY_REF" >> $GITHUB_OUTPUT
          echo "Triggered run ID: $RUN_ID"

      - name: Wait for Deploy to Complete
        env:
          GH_TOKEN: ${{ secrets.ACTIONS_TOKEN }}
        run: |
          echo "Waiting for deployment to complete..."
          gh run watch ${{ steps.trigger.outputs.run_id }} --exit-status

  # =============================================================================
  # Task: docker-cleanup
  # Removes unused Docker images, containers, and volumes to free disk space.
  # Runs weekly on schedule, or can be triggered manually.
  # =============================================================================
  docker-cleanup:
    if: |
      always() &&
      ((github.event_name == 'workflow_dispatch' && inputs.task == 'docker-cleanup') ||
      (github.event_name == 'schedule' && needs.schedule-gate.outputs.should_run == 'true' && needs.schedule-gate.outputs.task == 'docker-cleanup'))
    needs: [schedule-gate]
    runs-on: ubuntu-latest
    timeout-minutes: 15
    outputs:
      instances_cleaned: ${{ steps.cleanup.outputs.instances_cleaned }}
      space_freed: ${{ steps.cleanup.outputs.space_freed }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ vars.AWS_ROLE_ARN }}
          aws-region: ${{ vars.AWS_REGION || 'us-east-1' }}

      - name: Discover Graph Instances
        id: instances
        run: |
          # For manual runs, use selected environment; for scheduled, do both
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            ENVS="${{ inputs.environment }}"
          else
            ENVS="staging prod"
          fi

          INSTANCE_IDS=""
          for ENV in $ENVS; do
            echo "ðŸ” Discovering instances for $ENV..."

            # Find LadybugDB writer instances by tag
            WRITERS=$(aws ec2 describe-instances \
              --filters \
                "Name=tag:Environment,Values=$ENV" \
                "Name=tag:LadybugRole,Values=writer" \
                "Name=instance-state-name,Values=running" \
              --query "Reservations[].Instances[].InstanceId" \
              --output text 2>/dev/null || echo "")

            # Find shared-writer instances
            SHARED_WRITERS=$(aws ec2 describe-instances \
              --filters \
                "Name=tag:Environment,Values=$ENV" \
                "Name=tag:LadybugRole,Values=shared-writer" \
                "Name=instance-state-name,Values=running" \
              --query "Reservations[].Instances[].InstanceId" \
              --output text 2>/dev/null || echo "")

            for ID in $WRITERS $SHARED_WRITERS; do
              if [ -n "$ID" ]; then
                INSTANCE_IDS="$INSTANCE_IDS $ID"
                echo "  Found: $ID"
              fi
            done
          done

          INSTANCE_IDS=$(echo $INSTANCE_IDS | xargs)
          echo "instance_ids=$INSTANCE_IDS" >> $GITHUB_OUTPUT
          echo "ðŸ“‹ Total instances to clean: $(echo $INSTANCE_IDS | wc -w | xargs)"

      - name: Run Docker Cleanup
        id: cleanup
        run: |
          INSTANCE_IDS="${{ steps.instances.outputs.instance_ids }}"
          if [ -z "$INSTANCE_IDS" ]; then
            echo "::warning::No instances to clean"
            echo "instances_cleaned=0" >> $GITHUB_OUTPUT
            echo "space_freed=0" >> $GITHUB_OUTPUT
            exit 0
          fi

          CLEANED=0
          TOTAL_FREED=""

          for INSTANCE_ID in $INSTANCE_IDS; do
            echo "ðŸ§¹ Cleaning Docker on $INSTANCE_ID..."

            # Send cleanup command
            COMMAND_ID=$(aws ssm send-command \
              --instance-ids "$INSTANCE_ID" \
              --document-name "AWS-RunShellScript" \
              --parameters commands="docker system prune -af --volumes 2>&1 && df -h / | tail -1" \
              --query 'Command.CommandId' \
              --output text)

            echo "  Command ID: $COMMAND_ID"

            # Wait for completion
            if aws ssm wait command-executed \
              --command-id "$COMMAND_ID" \
              --instance-id "$INSTANCE_ID" 2>/dev/null; then

              OUTPUT=$(aws ssm get-command-invocation \
                --command-id "$COMMAND_ID" \
                --instance-id "$INSTANCE_ID" \
                --query 'StandardOutputContent' \
                --output text 2>/dev/null || echo "")

              echo "  âœ… Cleanup completed"
              # Extract disk usage line
              DISK_LINE=$(echo "$OUTPUT" | grep -E '^/dev/' | tail -1 || echo "")
              if [ -n "$DISK_LINE" ]; then
                echo "  Disk: $DISK_LINE"
                TOTAL_FREED="$TOTAL_FREED\n$INSTANCE_ID: $DISK_LINE"
              fi
              CLEANED=$((CLEANED + 1))
            else
              echo "  âš ï¸ Cleanup timed out or failed"
              ERROR=$(aws ssm get-command-invocation \
                --command-id "$COMMAND_ID" \
                --instance-id "$INSTANCE_ID" \
                --query 'StandardErrorContent' \
                --output text 2>/dev/null || echo "Unknown error")
              echo "  Error: $ERROR"
            fi
          done

          echo "instances_cleaned=$CLEANED" >> $GITHUB_OUTPUT
          echo "space_freed<<EOF" >> $GITHUB_OUTPUT
          echo -e "$TOTAL_FREED" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

  # =============================================================================
  # Summary (runs for all tasks)
  # =============================================================================
  summary:
    needs: [ami-get-latest, ami-update-variable, ami-trigger-deploy, docker-cleanup]
    if: always()
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
      - name: Generate Docker Cleanup Summary
        if: |
          (github.event_name == 'workflow_dispatch' && inputs.task == 'docker-cleanup') ||
          (github.event_name == 'schedule' && needs.docker-cleanup.result != 'skipped')
        run: |
          echo "## Graph Maintenance Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Task: Docker Cleanup ðŸ§¹" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Parameter | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|-----------|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| Trigger | ${{ github.event_name }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Instances Cleaned | ${{ needs.docker-cleanup.outputs.instances_cleaned || '0' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Result | ${{ needs.docker-cleanup.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [ -n "${{ needs.docker-cleanup.outputs.space_freed }}" ]; then
            echo "### Disk Status After Cleanup" >> $GITHUB_STEP_SUMMARY
            echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
            echo "${{ needs.docker-cleanup.outputs.space_freed }}" >> $GITHUB_STEP_SUMMARY
            echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "---" >> $GITHUB_STEP_SUMMARY
          echo "Triggered by: **${{ github.actor }}** at $(date -u +%Y-%m-%dT%H:%M:%SZ)" >> $GITHUB_STEP_SUMMARY

      - name: Generate AMI Update Summary
        if: |
          (github.event_name == 'workflow_dispatch' && inputs.task == 'update-ami') ||
          (github.event_name == 'schedule' && needs.ami-get-latest.result != 'skipped')
        run: |
          echo "## Graph Maintenance Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Task: Update AMI" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Parameter | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|-----------|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| Trigger | ${{ github.event_name }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Environment | ${{ needs.ami-get-latest.outputs.environment }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Variable | \`${{ needs.ami-get-latest.outputs.var_name }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Previous AMI | \`${{ needs.ami-get-latest.outputs.current_ami }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Latest AMI | \`${{ needs.ami-get-latest.outputs.ami_id }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| AMI Name | ${{ needs.ami-get-latest.outputs.ami_name }} |" >> $GITHUB_STEP_SUMMARY
          echo "| AMI Changed | ${{ needs.ami-get-latest.outputs.ami_changed }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Trigger Deploy | ${{ needs.ami-get-latest.outputs.trigger_deploy }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Deploy Ref | \`${{ needs.ami-trigger-deploy.outputs.deploy_ref || 'skipped' }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Job Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Job | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|-----|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| Get Latest AMI | ${{ needs.ami-get-latest.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Update Variable | ${{ needs.ami-update-variable.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Trigger Deploy | ${{ needs.ami-trigger-deploy.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Show warning if ACTIONS_TOKEN was missing
          if [ "${{ needs.ami-get-latest.outputs.has_token }}" != "true" ]; then
            echo "### âš ï¸ ACTIONS_TOKEN Not Set" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Variable update and deployment were skipped because ACTIONS_TOKEN is not configured." >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "To enable automatic updates, set the secret:" >> $GITHUB_STEP_SUMMARY
            echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
            echo "gh secret set ACTIONS_TOKEN" >> $GITHUB_STEP_SUMMARY
            echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            if [ "${{ needs.ami-get-latest.outputs.ami_changed }}" == "true" ]; then
              echo "To manually update the variable:" >> $GITHUB_STEP_SUMMARY
              echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
              echo "gh variable set ${{ needs.ami-get-latest.outputs.var_name }} --body \"${{ needs.ami-get-latest.outputs.ami_id }}\"" >> $GITHUB_STEP_SUMMARY
              echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
            fi
          fi

          echo "---" >> $GITHUB_STEP_SUMMARY
          echo "Triggered by: **${{ github.actor }}** at $(date -u +%Y-%m-%dT%H:%M:%SZ)" >> $GITHUB_STEP_SUMMARY
