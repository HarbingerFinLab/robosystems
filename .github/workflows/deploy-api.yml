name: Deploy API

on:
  workflow_call:
    inputs:
      # Stack & Repository Configuration
      stack_name:
        description: "CloudFormation stack name"
        required: true
        type: string
      environment:
        description: "Environment to deploy to (prod, staging, or dev)"
        required: true
        type: string

      # GHA Runner Configuration
      runner_config:
        description: "GitHub Actions runner configuration (JSON array)"
        required: false
        type: string
        default: '["ubuntu-latest"]'

      # AWS Configuration
      aws_region:
        description: "AWS region for deployment"
        required: true
        type: string
      vpc_id:
        description: "VPC ID for ECS tasks"
        required: true
        type: string
      subnet_ids:
        description: "Private subnet IDs for ECS tasks (comma-separated)"
        required: true
        type: string
      public_subnet_ids:
        description: "Public subnet IDs for ALB (comma-separated). Required when domain_name is provided."
        required: false
        type: string
        default: ""
      admin_allowed_cidrs:
        description: "Comma-separated CIDR blocks allowed to access Admin API. Required when domain_name is provided."
        required: false
        type: string
        default: ""

      # Container & Application Configuration
      ecr_repository_url:
        description: "Full ECR repository URL (e.g., 123456789.dkr.ecr.us-east-1.amazonaws.com/robosystems)"
        required: true
        type: string
      ecr_image_tag:
        description: "Docker image tag"
        required: true
        type: string

      # ECS & Compute Configuration
      desired_count:
        description: "Number of ECS tasks to run"
        required: true
        type: string
      cpu:
        description: "CPU units for ECS task (256 = 0.25 vCPU)"
        required: false
        type: string
        default: "512"
      memory:
        description: "Memory in MiB for ECS task"
        required: false
        type: string
        default: "1024"
      fargate_weight:
        description: "Weight for FARGATE capacity provider (On-Demand instances)"
        required: false
        type: string
        default: "20"
      fargate_spot_weight:
        description: "Weight for FARGATE_SPOT capacity provider (Spot instances)"
        required: false
        type: string
        default: "80"

      # Auto-scaling Configuration
      min_capacity:
        description: "Minimum number of tasks for auto scaling"
        required: false
        type: string
        default: "1"
      max_capacity:
        description: "Maximum number of tasks for auto scaling"
        required: false
        type: string
        default: "10"
      cpu_target_value:
        description: "Target CPU utilization percentage for auto scaling"
        required: false
        type: string
        default: "70"
      memory_target_value:
        description: "Target Memory utilization percentage for auto scaling"
        required: false
        type: string
        default: "60"

      # Access Mode Configuration
      api_access_mode:
        description: "API access mode: 'public' (HTTPS with domain), 'public-http' (HTTP via ALB DNS), 'internal' (via bastion tunnel)"
        required: false
        type: string
        default: "internal"

      # Domain & DNS Configuration (Required only when api_access_mode=public)
      domain_name:
        description: "Full domain name for the application (e.g., api.robosystems.ai). Required when api_access_mode=public."
        required: false
        type: string
        default: ""
      domain_name_root:
        description: "Root domain name for Route 53 hosted zone. Required when api_access_mode=public."
        required: false
        type: string
        default: ""

      # Cache Configuration
      valkey_url:
        description: "Valkey ElastiCache endpoint URL from Valkey stack"
        required: true
        type: string
      valkey_sg_id:
        description: "Security group ID for applications connecting to Valkey"
        required: true
        type: string

      # S3 Bucket Configuration (from S3 stack outputs)
      shared_processed_bucket_arn:
        description: "ARN of shared processed data bucket (from S3 stack)"
        required: true
        type: string
      deployment_bucket_arn:
        description: "ARN of deployment bucket (from S3 stack)"
        required: true
        type: string
      user_data_bucket_arn:
        description: "ARN of user data bucket (from S3 stack)"
        required: true
        type: string

      # Other Configuration
      prometheus_stack_name:
        description: "Name of the Prometheus CloudFormation stack for this environment"
        required: false
        type: string
        default: ""
      refresh_ecs_service:
        description: "Refresh ECS service after deployment"
        required: false
        type: string
        default: "true"

      # WAF Configuration (optional)
      waf_enabled:
        description: "Enable WAF protection for the API"
        required: false
        type: string
        default: "false"
      waf_stack_name:
        description: "CloudFormation stack name for WAF"
        required: false
        type: string
        default: ""
      waf_rate_limit_per_ip:
        description: "Maximum requests per 5-minute window per IP"
        required: false
        type: string
        default: "10000"
      waf_enable_geo_blocking:
        description: "Enable geographic blocking (blocks non-US traffic)"
        required: false
        type: string
        default: "false"
      waf_enable_aws_managed_rules:
        description: "Enable AWS Managed Core Rule Set"
        required: false
        type: string
        default: "true"

      # Notification Configuration
      aws_sns_alert_email:
        description: "Email address for SNS alerts and notifications"
        required: true
        type: string

    secrets:
      ACTIONS_TOKEN:
        description: "GitHub token for checkout (optional - falls back to github.token)"
        required: false

    outputs:
      api_sg_id:
        description: "API ECS task security group ID (for Dagster access)"
        value: ${{ jobs.deploy.outputs.api_sg_id }}

jobs:
  deploy:
    runs-on: ${{ fromJSON(inputs.runner_config) }}
    timeout-minutes: 25
    permissions:
      id-token: write
      contents: read
    outputs:
      api_sg_id: ${{ steps.get-outputs.outputs.api_sg_id }}
      api_alb_arn: ${{ steps.get-outputs.outputs.api_alb_arn }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          repository: ${{ github.repository }}
          ref: ${{ github.ref }}
          token: ${{ secrets.ACTIONS_TOKEN || github.token }}

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ vars.AWS_ROLE_ARN }}
          aws-region: ${{ inputs.aws_region }}

      - name: Deploy API CloudFormation Stack
        id: deploy-stack
        run: |
          # Determine access mode and validate configuration
          API_ACCESS_MODE="${{ inputs.api_access_mode }}"
          DOMAIN_NAME="${{ inputs.domain_name }}"
          HOSTED_ZONE_ID=""

          echo "API Access Mode: $API_ACCESS_MODE"

          case "$API_ACCESS_MODE" in
            "public")
              if [ -z "$DOMAIN_NAME" ]; then
                echo "ERROR: domain_name is required when api_access_mode=public"
                exit 1
              fi
              echo "ðŸŒ Public deployment with custom domain: $DOMAIN_NAME"
              # Look up the hosted zone ID for the root domain
              HOSTED_ZONE_ID=$(aws route53 list-hosted-zones | jq -r ".HostedZones[] | select(.Name==\"${{ inputs.domain_name_root }}.\") | .Id" | cut -d'/' -f3)
              if [ -z "$HOSTED_ZONE_ID" ]; then
                echo "ERROR: No hosted zone found for domain ${{ inputs.domain_name_root }}"
                exit 1
              fi
              echo "   Hosted zone: $HOSTED_ZONE_ID"
              ;;
            "public-http")
              echo "ðŸŒ Public deployment with ALB DNS (HTTP only, no TLS)"
              echo "   Access will be via ALB DNS name"
              ;;
            "internal")
              echo "ðŸ”’ Internal-only deployment"
              echo "   Access will be via bastion tunnel only"
              ;;
            *)
              echo "ERROR: Invalid api_access_mode: $API_ACCESS_MODE"
              echo "   Valid values: public, public-http, internal"
              exit 1
              ;;
          esac

          if aws cloudformation describe-stacks --stack-name ${{ inputs.stack_name }} 2>&1 | grep -q 'Stack with id ${{ inputs.stack_name }} does not exist'; then
            STACK_ACTION="create-stack"
            echo "Creating new stack ${{ inputs.stack_name }}"
            echo "is_new_stack=true" >> $GITHUB_OUTPUT
          else
            STACK_ACTION="update-stack"
            echo "Updating existing stack ${{ inputs.stack_name }}"
            echo "is_new_stack=false" >> $GITHUB_OUTPUT
          fi

          # Build parameters
          API_STACK_PARAMS="ParameterKey=Environment,ParameterValue=${{ inputs.environment }} \
                ParameterKey=VpcId,ParameterValue=${{ inputs.vpc_id }} \
                ParameterKey=SubnetIds,ParameterValue=\"${{ inputs.subnet_ids }}\" \
                ParameterKey=PublicSubnetIds,ParameterValue=\"${{ inputs.public_subnet_ids }}\" \
                ParameterKey=AdminAllowedCidrBlocks,ParameterValue=\"${{ inputs.admin_allowed_cidrs }}\" \
                ParameterKey=ECRRepositoryUrl,ParameterValue=${{ inputs.ecr_repository_url }} \
                ParameterKey=ECRImageTag,ParameterValue=${{ inputs.ecr_image_tag }} \
                ParameterKey=DesiredCount,ParameterValue=${{ inputs.desired_count }} \
                ParameterKey=Cpu,ParameterValue=${{ inputs.cpu }} \
                ParameterKey=Memory,ParameterValue=${{ inputs.memory }} \
                ParameterKey=ValkeyUrl,ParameterValue=${{ inputs.valkey_url }} \
                ParameterKey=ValkeyClientSecurityGroupId,ParameterValue=${{ inputs.valkey_sg_id }} \
                ParameterKey=ApiAccessMode,ParameterValue=${{ inputs.api_access_mode }} \
                ParameterKey=DomainName,ParameterValue=\"${{ inputs.domain_name }}\" \
                ParameterKey=RootDomainName,ParameterValue=\"${{ inputs.domain_name_root }}\" \
                ParameterKey=HostedZoneId,ParameterValue=\"$HOSTED_ZONE_ID\" \
                ParameterKey=MinCapacity,ParameterValue=${{ inputs.min_capacity }} \
                ParameterKey=MaxCapacity,ParameterValue=${{ inputs.max_capacity }} \
                ParameterKey=CPUTargetValue,ParameterValue=${{ inputs.cpu_target_value }} \
                ParameterKey=MemoryTargetValue,ParameterValue=${{ inputs.memory_target_value }} \
                ParameterKey=FargateSpotWeight,ParameterValue=${{ inputs.fargate_spot_weight }} \
                ParameterKey=FargateWeight,ParameterValue=${{ inputs.fargate_weight }} \
                ParameterKey=PrometheusStackName,ParameterValue=\"${{ inputs.prometheus_stack_name }}\" \
                ParameterKey=EmailFromAddress,ParameterValue=\"${{ inputs.aws_sns_alert_email }}\" \
                ParameterKey=SharedProcessedBucketArn,ParameterValue=\"${{ inputs.shared_processed_bucket_arn }}\" \
                ParameterKey=DeploymentBucketArn,ParameterValue=\"${{ inputs.deployment_bucket_arn }}\" \
                ParameterKey=UserDataBucketArn,ParameterValue=\"${{ inputs.user_data_bucket_arn }}\""

          # Deploy or update the stack
          if [ "$STACK_ACTION" = "create-stack" ]; then
            # Create new stack
            aws cloudformation $STACK_ACTION \
              --stack-name ${{ inputs.stack_name }} \
              --template-body file://cloudformation/api.yaml \
              --capabilities CAPABILITY_IAM CAPABILITY_NAMED_IAM \
              --parameters $API_STACK_PARAMS \
              --tags \
                Key=Environment,Value=${{ inputs.environment }} \
                Key=Service,Value=RoboSystems \
                Key=Component,Value=API \
                Key=Repository,Value=${{ github.repository }} \
                Key=CreatedBy,Value=GitHubActions
          else
            # Update existing stack, handling "No updates" error
            UPDATE_OUTPUT=$(aws cloudformation $STACK_ACTION \
              --stack-name ${{ inputs.stack_name }} \
              --template-body file://cloudformation/api.yaml \
              --capabilities CAPABILITY_IAM CAPABILITY_NAMED_IAM \
              --parameters $API_STACK_PARAMS \
              --tags \
                Key=Environment,Value=${{ inputs.environment }} \
                Key=Service,Value=RoboSystems \
                Key=Component,Value=API \
                Key=Repository,Value=${{ github.repository }} \
                Key=CreatedBy,Value=GitHubActions 2>&1) || true

            # Check if the error was "No updates are to be performed"
            if echo "$UPDATE_OUTPUT" | grep -q "No updates are to be performed"; then
              echo "Stack is already up to date - no changes needed"
              echo "is_new_stack=false" >> $GITHUB_OUTPUT
            elif echo "$UPDATE_OUTPUT" | grep -q "error"; then
              echo "Error updating stack: $UPDATE_OUTPUT"
              exit 1
            else
              echo "Stack update initiated successfully"
              echo "is_new_stack=false" >> $GITHUB_OUTPUT
            fi
          fi

      - name: Monitor Stack Deployment
        uses: ./.github/actions/monitor-stack-deployment
        with:
          stack-name: ${{ inputs.stack_name }}
          timeout: "1800"
          interval: "10"

      - name: Get Stack Outputs
        id: get-outputs
        run: |
          # Get API security group ID for Dagster access
          API_SG_ID=$(aws cloudformation describe-stacks \
            --stack-name ${{ inputs.stack_name }} \
            --query "Stacks[0].Outputs[?OutputKey=='ApiSecurityGroupId'].OutputValue" \
            --output text 2>/dev/null || echo "")
          echo "api_sg_id=$API_SG_ID" >> $GITHUB_OUTPUT
          echo "API Security Group ID: $API_SG_ID"

          # Get API ALB ARN for WAF (only exists when api_access_mode is public or public-http)
          API_ALB_ARN=$(aws cloudformation describe-stacks \
            --stack-name ${{ inputs.stack_name }} \
            --query "Stacks[0].Outputs[?OutputKey=='ApiALBArn'].OutputValue" \
            --output text 2>/dev/null || echo "")
          echo "api_alb_arn=$API_ALB_ARN" >> $GITHUB_OUTPUT
          if [ -n "$API_ALB_ARN" ]; then
            echo "API ALB ARN: $API_ALB_ARN"
          fi

      - name: Refresh ECS Service
        if: inputs.refresh_ecs_service != 'false' && steps.deploy-stack.outputs.is_new_stack != 'true'
        uses: ./.github/actions/refresh-ecs
        with:
          stack-name: ${{ inputs.stack_name }}
          skip-autoscale-refresh: "false"
          service-type: "api"
          max-wait-time: "600"
          service-stability-delay: "30"

  # WAF deployment as separate job (only runs when enabled and public)
  waf:
    needs: deploy
    if: inputs.waf_enabled == 'true' && inputs.waf_stack_name != '' && inputs.api_access_mode == 'public'
    runs-on: ${{ fromJSON(inputs.runner_config) }}
    timeout-minutes: 10
    permissions:
      id-token: write
      contents: read

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          repository: ${{ github.repository }}
          ref: ${{ github.ref }}
          token: ${{ secrets.ACTIONS_TOKEN || github.token }}

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ vars.AWS_ROLE_ARN }}
          aws-region: ${{ inputs.aws_region }}

      - name: Deploy WAF Stack
        run: |
          API_ALB_ARN="${{ needs.deploy.outputs.api_alb_arn }}"

          if [ -z "$API_ALB_ARN" ]; then
            echo "Error: Could not find API ALB ARN from deploy job"
            exit 1
          fi

          echo "Deploying WAF protection for ALB"

          if aws cloudformation describe-stacks --stack-name ${{ inputs.waf_stack_name }} 2>&1 | grep -q 'Stack with id .* does not exist'; then
            STACK_ACTION="create-stack"
            echo "Creating new WAF stack: ${{ inputs.waf_stack_name }}"
          else
            STACK_ACTION="update-stack"
            echo "Updating existing WAF stack: ${{ inputs.waf_stack_name }}"
          fi

          WAF_PARAMS="ParameterKey=Environment,ParameterValue=${{ inputs.environment }}"
          WAF_PARAMS="$WAF_PARAMS ParameterKey=ApiAlbArn,ParameterValue='$API_ALB_ARN'"
          WAF_PARAMS="$WAF_PARAMS ParameterKey=RateLimitPerIP,ParameterValue=${{ inputs.waf_rate_limit_per_ip }}"
          WAF_PARAMS="$WAF_PARAMS ParameterKey=EnableGeoBlocking,ParameterValue=${{ inputs.waf_enable_geo_blocking }}"
          WAF_PARAMS="$WAF_PARAMS ParameterKey=EnableAwsManagedRules,ParameterValue=${{ inputs.waf_enable_aws_managed_rules }}"
          WAF_PARAMS="$WAF_PARAMS ParameterKey=AllowedIPs,ParameterValue='${{ inputs.admin_allowed_cidrs }}'"

          if [ "$STACK_ACTION" = "create-stack" ]; then
            aws cloudformation $STACK_ACTION \
              --stack-name ${{ inputs.waf_stack_name }} \
              --template-body file://cloudformation/waf.yaml \
              --capabilities CAPABILITY_IAM CAPABILITY_NAMED_IAM \
              --parameters $WAF_PARAMS \
              --tags \
                Key=Environment,Value=${{ inputs.environment }} \
                Key=Service,Value=RoboSystems \
                Key=Component,Value=WAF \
                Key=ManagedBy,Value="GitHub Actions"

            echo "Waiting for WAF stack creation..."
            aws cloudformation wait stack-create-complete \
              --stack-name ${{ inputs.waf_stack_name }} || {
              echo "WAF stack creation failed"
              aws cloudformation describe-stack-events \
                --stack-name ${{ inputs.waf_stack_name }} \
                --query 'StackEvents[?ResourceStatus==`CREATE_FAILED`].[LogicalResourceId, ResourceStatusReason]' \
                --output table
              exit 1
            }
          else
            UPDATE_OUTPUT=$(aws cloudformation $STACK_ACTION \
              --stack-name ${{ inputs.waf_stack_name }} \
              --template-body file://cloudformation/waf.yaml \
              --capabilities CAPABILITY_IAM CAPABILITY_NAMED_IAM \
              --parameters $WAF_PARAMS \
              --tags \
                Key=Environment,Value=${{ inputs.environment }} \
                Key=Service,Value=RoboSystems \
                Key=Component,Value=WAF \
                Key=ManagedBy,Value="GitHub Actions" \
              2>&1 || true)

            if echo "$UPDATE_OUTPUT" | grep -q "No updates are to be performed"; then
              echo "No changes detected in WAF stack"
            else
              echo "Waiting for WAF stack update..."
              aws cloudformation wait stack-update-complete \
                --stack-name ${{ inputs.waf_stack_name }} || {
                echo "WAF stack update failed"
                aws cloudformation describe-stack-events \
                  --stack-name ${{ inputs.waf_stack_name }} \
                  --query 'StackEvents[?ResourceStatus==`UPDATE_FAILED`].[LogicalResourceId, ResourceStatusReason]' \
                  --output table
                exit 1
              }
            fi
          fi

          echo "WAF stack deployed successfully"

          # Get WAF outputs for summary
          ESTIMATED_COST=$(aws cloudformation describe-stacks \
            --stack-name ${{ inputs.waf_stack_name }} \
            --query "Stacks[0].Outputs[?OutputKey=='EstimatedMonthlyCost'].OutputValue" \
            --output text)

          echo "WAF Deployment Summary"
          echo "======================"
          echo "Rate Limit: ${{ inputs.waf_rate_limit_per_ip }} requests/5min"
          echo "Geo Blocking: ${{ inputs.waf_enable_geo_blocking }}"
          echo "AWS Managed Rules: ${{ inputs.waf_enable_aws_managed_rules }}"
          echo "Estimated monthly cost: $ESTIMATED_COST"
